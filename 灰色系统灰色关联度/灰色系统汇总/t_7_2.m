A =[38453.9,35541.81,57236.4,46120.8,61158.05,43989.54];
x0=[20674,15867,24460,23531,40502,34100;
    369,337,304,399,446,415;
    104.2111,105.4653,188.2776,115.591,137.1257,105.9989];
[n,m]=size(x0);
AGO=cumsum(A);
T=1;
x1=zeros(n,m+T);
for k=1:(m-1)
    Z(k)=(AGO(k)+AGO(k+1))/2; %Z(i)为xi(1)的紧邻均值生成序列
end
for i=1:n
    for j=1:m
        for k=1:j
            x1(i,j)=x1(i,j)+x0(i,k);%原始数据一次累加,得到xi(1)
        end
    end
end
x11=x1(:,1:m);
X=x1(:,2:m)';%截取矩阵
Yn =A;%Yn为常数项向量
Yn(1)=[]; %从第二个数开始，即x(2),x(3)...
Yn=Yn';
%Yn=A(:,2:m)';
B=[-Z',X];
C=((B'*B)\(B'*Yn))';%由公式建立GM(1,n)模型
a=C(1)
b=C(:,2:n+1)
F=[];
F(1)=A(1);
u=zeros(1,m+1);
for i=1:m
    for j=1:n
        u(i)=u(i)+(b(j)*x11(j,i));
    end
end
for k=2:m
    F(k)=(A(1)-u(k)/a)/exp(a*(k-1))+u(k)/a;
end
G=[];
G(1)=A(1);
for k=2:m
    G(k)=F(k)-F(k-1);%两者做差还原原序列，得到预测数据
end
G
t1=1:m;
t2=1:m;
plot(t1,A,'bo--');
hold on;
plot(t2,G,'r*-'); 
title('预测结果');
legend('真实值','预测值');